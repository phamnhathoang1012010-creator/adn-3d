<!DOCTYPE html>
<html lang="vi">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>M√¥ ph·ªèng t√°i b·∫£n ADN ‚Äì SGK</title>
<style>
body { margin:0; background:black; overflow:hidden; color:white; font-family:Arial }
#ui { position:fixed; bottom:10px; left:50%; transform:translateX(-50%); }
button {
  padding:8px 12px; margin:4px;
  border:none; border-radius:8px; cursor:pointer;
}
button.active { background:#2ecc71; color:black; }
#legend { position:fixed; top:10px; left:10px; font-size:14px; }
</style>
</head>
<body>

<div id="legend">
üü° A &nbsp; üîµ T &nbsp; üü• G &nbsp; üü¢ C<br>
Ch·∫ø ƒë·ªô: t·ª´ng b∆∞·ªõc SGK
</div>

<div id="ui">
<button id="s1" class="active">B∆∞·ªõc 1</button>
<button id="s2">B∆∞·ªõc 2</button>
<button id="s3">B∆∞·ªõc 3</button>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/examples/js/controls/OrbitControls.js"></script>

<script>
/* ===== SCENE ===== */
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x000000);

const camera = new THREE.PerspectiveCamera(70, innerWidth/innerHeight, 0.1, 1000);
camera.position.set(0, 0, 35);
camera.lookAt(0,0,0);

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth, innerHeight);
document.body.appendChild(renderer.domElement);

/* ===== CONTROLS (FIX ƒêEN M√ÄN) ===== */
const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.target.set(0,0,0);
controls.update();

/* ===== RESIZE ===== */
window.onresize = ()=>{
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
};

/* ===== LIGHT ===== */
scene.add(new THREE.AmbientLight(0xffffff,0.8));
const dl = new THREE.DirectionalLight(0xffffff,1);
dl.position.set(10,10,10);
scene.add(dl);

/* ===== DNA ===== */
const branch1 = new THREE.Group();
const branch2 = new THREE.Group();
scene.add(branch1, branch2);

for(let i=0;i<14;i++){
  const b1 = new THREE.Mesh(
    new THREE.BoxGeometry(0.8,0.8,0.8),
    new THREE.MeshStandardMaterial({color:0xf1c40f})
  );
  b1.position.set(Math.sin(i*0.6)*3, i-7, Math.cos(i*0.6));
  branch1.add(b1);

  const b2 = new THREE.Mesh(
    new THREE.BoxGeometry(0.8,0.8,0.8),
    new THREE.MeshStandardMaterial({color:0x3498db})
  );
  b2.position.set(6, i-7, 0);
  branch2.add(b2);
}

/* ===== HELICASE ===== */
const helicase = new THREE.Mesh(
  new THREE.CylinderGeometry(1.2,1.2,1,32),
  new THREE.MeshStandardMaterial({color:0x7bed9f})
);
helicase.visible = false;
scene.add(helicase);

/* ===== OKAZAKI ===== */
const okazaki = new THREE.Group();
for(let i=0;i<5;i++){
  const f = new THREE.Mesh(
    new THREE.BoxGeometry(0.7,0.7,0.7),
    new THREE.MeshStandardMaterial({color:0xff5722})
  );
  f.position.set(4,-10-i*1.2,0);
  okazaki.add(f);
}
okazaki.visible = false;
scene.add(okazaki);

/* ===== STEP CONTROL ===== */
let step = 1;
s1.onclick=()=>{step=1;updateStep()};
s2.onclick=()=>{step=2;updateStep()};
s3.onclick=()=>{step=3;updateStep()};

function updateStep(){
  s1.classList.toggle("active",step===1);
  s2.classList.toggle("active",step===2);
  s3.classList.toggle("active",step===3);

  helicase.visible = step>=2;
  okazaki.visible = step>=3;
}
updateStep();

/* ===== ANIMATION ===== */
function animate(){
  requestAnimationFrame(animate);

  if(step>=2){
    branch1.rotation.y += 0.01;
    helicase.position.y += 0.05;
    if(helicase.position.y>6) helicase.position.y=-6;
  }

  if(step>=3){
    okazaki.children.forEach(o=>{
      o.position.y += 0.01;
      if(o.position.y>0) o.position.y=-10;
    });
  }

  controls.update();
  renderer.render(scene,camera);
}
animate();
</script>
</body>
</html>
