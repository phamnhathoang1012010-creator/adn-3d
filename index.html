<!DOCTYPE html>
<html lang="vi">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ADN 3D SGK</title>
<style>
body{margin:0;overflow:hidden;background:black;color:white}
#ui{position:fixed;top:10px;left:50%;transform:translateX(-50%);display:flex;gap:8px;z-index:10}
button{padding:8px 12px;background:#222;color:white;border:1px solid #555;border-radius:6px}
#sliderBox{position:fixed;bottom:20px;left:50%;transform:translateX(-50%);width:80%;display:none}
input{width:100%}
</style>
</head>
<body>

<div id="ui">
  <button onclick="setMode('spin')">Xoắn</button>
  <button onclick="setMode('open')">Tháo</button>
  <button onclick="setMode('copy')">Nhân đôi</button>
</div>

<div id="sliderBox">
  <input id="slider" type="range" min="0" max="100" value="0">
</div>

<script type="module">
import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.module.js";

const scene=new THREE.Scene();
scene.background=new THREE.Color(0x000000);

const camera=new THREE.PerspectiveCamera(60,innerWidth/innerHeight,0.1,1000);
camera.position.z=22;

const renderer=new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth,innerHeight);
document.body.appendChild(renderer.domElement);

// LIGHT
scene.add(new THREE.AmbientLight(0xffffff,0.4));
const l=new THREE.PointLight(0xffffff,1);
l.position.set(10,10,10);
scene.add(l);

// ADN GROUP
const dna=new THREE.Group();
scene.add(dna);

// BASE COLORS (SGK)
const materials={
  A:new THREE.MeshStandardMaterial({color:0x00ff88}),
  T:new THREE.MeshStandardMaterial({color:0x00aaff}),
  G:new THREE.MeshStandardMaterial({color:0xffaa00}),
  C:new THREE.MeshStandardMaterial({color:0xff4444}),
  bond:new THREE.MeshStandardMaterial({color:0xffffff})
};

const geoBase=new THREE.SphereGeometry(0.35,16,16);
const geoBond=new THREE.CylinderGeometry(0.08,0.08,2,8);

const pairs=["A","T","G","C"];
const chainA=[],chainB=[],bonds=[],copyChain=[];

for(let i=0;i<36;i++){
  const type=pairs[i%4];
  const pair= type==="A"?"T":type==="T"?"A":type==="G"?"C":"G";
  const a=i*0.45;
  const y=i*0.35-6;

  const b1=new THREE.Mesh(geoBase,materials[type]);
  const b2=new THREE.Mesh(geoBase,materials[pair]);

  b1.position.set(Math.cos(a)*4,y,Math.sin(a)*4);
  b2.position.set(Math.cos(a+Math.PI)*4,y,Math.sin(a+Math.PI)*4);

  dna.add(b1,b2);
  chainA.push(b1);
  chainB.push(b2);

  // bond
  const bond=new THREE.Mesh(geoBond,materials.bond);
  bond.position.y=y;
  bond.rotation.z=Math.PI/2;
  dna.add(bond);
  bonds.push(bond);

  // copy
  const c=new THREE.Mesh(geoBase,materials[pair]);
  c.visible=false;
  dna.add(c);
  copyChain.push(c);
}

// MODE
let mode="spin";
const slider=document.getElementById("slider");
const sliderBox=document.getElementById("sliderBox");

window.setMode=m=>{
  mode=m;
  slider.value=0;
  sliderBox.style.display=(m==="open"||m==="copy")?"block":"none";
  copyChain.forEach(c=>c.visible=false);
};

// SLIDER
slider.oninput=()=>{
  const t=slider.value/100;
  if(mode==="open"){
    chainA.forEach((b,i)=>b.position.x=Math.cos(i*0.45)*4 - t*3);
    chainB.forEach((b,i)=>b.position.x=Math.cos(i*0.45+Math.PI)*4 + t*3);
    bonds.forEach(b=>b.scale.y=1-t);
  }
  if(mode==="copy"){
    copyChain.forEach((c,i)=>{
      c.visible=t>0;
      c.position.set(
        Math.cos(i*0.45+Math.PI)*4+t*3,
        i*0.35-6,
        Math.sin(i*0.45+Math.PI)*4
      );
    });
  }
};

// ROTATE HAND + MOUSE
let down=false,lx=0,ly=0;
addEventListener("mousedown",e=>{down=true;lx=e.clientX;ly=e.clientY});
addEventListener("mouseup",()=>down=false);
addEventListener("mousemove",e=>{
  if(!down)return;
  dna.rotation.y+=(e.clientX-lx)*0.005;
  dna.rotation.x+=(e.clientY-ly)*0.005;
  lx=e.clientX;ly=e.clientY;
});
addEventListener("touchstart",e=>{down=true;lx=e.touches[0].clientX;ly=e.touches[0].clientY});
addEventListener("touchend",()=>down=false);
addEventListener("touchmove",e=>{
  if(!down)return;
  dna.rotation.y+=(e.touches[0].clientX-lx)*0.005;
  dna.rotation.x+=(e.touches[0].clientY-ly)*0.005;
  lx=e.touches[0].clientX;ly=e.touches[0].clientY;
});

// ANIMATE
function animate(){
  requestAnimationFrame(animate);
  if(mode==="spin") dna.rotation.y+=0.01;
  renderer.render(scene,camera);
}
animate();

addEventListener("resize",()=>{
  camera.aspect=innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth,innerHeight);
});
</script>
</body>
</html>
