const dna = new THREE.Group();
scene.add(dna);

const chainA = [], chainB = [], bonds = [];

const R = 5.5;      // khoảng cách 2 mạch
const H = 0.6;      // độ cao mỗi base
const STEP = 0.45;

const baseGeo = new THREE.SphereGeometry(0.4, 16, 16);
const bondGeo = new THREE.CylinderGeometry(0.05, 0.05, 1, 8);

const colors = {
  A: 0xff4444,
  T: 0x4488ff,
  G: 0x44ff88,
  C: 0xffcc44
};

const pairs = { A:"T", T:"A", G:"C", C:"G" };
const bases = ["A","T","G","C"];

for (let i = 0; i < 40; i++) {
  const angle = i * STEP;
  const y = i * H - 12;

  const b1 = bases[Math.floor(Math.random() * 4)];
  const b2 = pairs[b1];

  const m1 = new THREE.Mesh(
    baseGeo,
    new THREE.MeshStandardMaterial({ color: colors[b1] })
  );
  const m2 = new THREE.Mesh(
    baseGeo,
    new THREE.MeshStandardMaterial({ color: colors[b2] })
  );

  // XOẮN ĐÚNG TRỤC
  m1.position.set(
    Math.cos(angle) * R,
    y,
    Math.sin(angle) * R
  );
  m2.position.set(
    Math.cos(angle + Math.PI) * R,
    y,
    Math.sin(angle + Math.PI) * R
  );

  dna.add(m1);
  dna.add(m2);
  chainA.push(m1);
  chainB.push(m2);

  // LIÊN KẾT HIĐRÔ NGANG
  const bond = new THREE.Mesh(
    bondGeo,
    new THREE.MeshStandardMaterial({
      color: 0xffffff,
      transparent: true,
      opacity: 0.8
    })
  );

  const mid = new THREE.Vector3()
    .addVectors(m1.position, m2.position)
    .multiplyScalar(0.5);

  bond.position.copy(mid);
  bond.lookAt(m2.position);
  bond.rotateX(Math.PI / 2);
  bond.scale.y = m1.position.distanceTo(m2.position);

  dna.add(bond);
  bonds.push(bond);
}
